---
title: 数组与矩阵
date: 2020-04-08 20:29:23
tags: 
- 数据结构
categories:
- Leetcode
---

## 1.重塑矩阵

[566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

**题目：** 在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。

如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

**示例：**

```
输入: 
nums = 
[[1,2],
 [3,4]]
r = 1, c = 4
输出: 
[[1,2,3,4]]
解释:
行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
```

**方法：** 先判断暴力遍历整个二维数组，将值存入一个一维数组numbers中，再新建一个二维数组arr，每次取出numbers中的第一个元素，作为arr [i] [j]的值(i<r,j<c)。

```javascript
var matrixReshape = function(nums, r, c) {
    let rows = nums.length; //矩阵的行数
    let columns = nums[0].length; //矩阵的列数
    if(rows*columns!=r*c)
        return nums;
    let numbers = new Array();
    for(let i=0;i<rows;++i)
    {
        for(let j=0;j<columns;++j)
        {
            numbers.push(nums[i][j]);
        }
    }
    let arr = new Array();     //先声明一维
    for(i=0;i<r;i++)
    {          
        arr[i]=new Array();    //再声明二维
    }
    for(i=0;i<r;++i)
    {
        for(j=0;j<c;++j)
        {
            arr[i][j] = numbers.shift();
        }
    }
    return arr;
};
```

**方法二：** 只需进行一次遍历，arr[i] [j] = nums [Math.trunc(index/columns)] [index % columns];Math.trunc(index/columns)是行号，index%columns是列号，可通过这种方式遍历原矩阵。

```javascript
var matrixReshape = function(nums, r, c) {
    let rows = nums.length,columns = nums[0].length; 
    if(rows*columns!=r*c)
        return nums;
    let arr = new Array();     //先声明一维
    for(let i=0;i<r;i++)
    {          
        arr[i]=new Array();    //再声明二维
    }
    var index = 0;
    for(let i=0;i<r;++i)
    {
        for(let j=0;j<c;++j)
        {
            arr[i][j] = nums[Math.trunc(index/columns)][index % columns];
            index++;
        }
    }
    return arr;
}
```

## 2.有序矩阵中第K小的元素

[378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

**题目：** 给定一个 *n x n* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

**示例：** 

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**方法：** 先用一个额外数组nums按顺序存储矩阵中的元素，再对数组进行排序，再返回数组中下标为k-1的值。

```javascript
var kthSmallest = function(matrix, k) {
    let nums = new Array();
    for(let i=0;i<matrix.length;++i)
    {
        for(let j=0;j<matrix[0].length;++j)
        {
            nums.push(matrix[i][j]);
        }
    }
    function sortNums(a,b)
    {
        return a-b;
    }
    nums.sort(sortNums);
    return nums[k-1];
};
```

**方法二：** 二分查找，第k小的值一定在[left,right]中，其中left=matrix[0] [0]，right=matrix[row] [col]。定义mid=(left+right)/2，每次查找矩阵中比mid小的元素个数，如果mid<k，则left=mid+1，否则，right=mid。最后，当left=right时，right即为第k小的值。

```javascript
var kthSmallest = function(matrix, k) {
    let row=matrix.length,col=matrix[0].length;
    let left=matrix[0][0],right=matrix[row-1][col-1];
    while(left<right)
    {
        let mid = Math.trunc((left+right)/2);
        let count = findcount(matrix,mid,row,col);
        if(count<k){
            left = mid +1;
        }else{
            right=mid;
        }
    }
    return right;
}
    function findcount(matrix,mid,row,col)
    {
        let i=0,j=col-1,count=0;
        while(i<row&&j>=0)
        {
            if(matrix[i][j]<=mid)
            {
                count += j+1;
                i++;
            }
            else
                j--;
        }
    return count;
}
```

## 3.对角元素相等的矩阵

[766. 托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)

**题目：** 如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。

给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。

**示例：** 

```
输入: 
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]
输出: True
```

**方法：** 每次将矩阵中的元素与右下方的元素相比较，若相等则继续，若不相等则返回false，最终返回true（既比较matrix[i] [j]与matrix[i+1] [j+1]是否相等）。

```javascript
var isToeplitzMatrix = function(matrix) 
{
    for(let i=0;i<matrix.length-1;++i)
    {
        for(let j=0;j<matrix[0].length-1;++j)
        {
            if(matrix[i][j]==matrix[i+1][j+1])
                continue;
            else
                return false;
        }
    }
    return true;
};
```

## 4.数组嵌套

**题目：** 索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到并返回最大的集合S，S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。

假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。

**示例：** 

```
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
```

**方法：** 暴力会超时。问题就是寻找数组中的最大环，因为环外的元素不会访问到环内，所以可以将访问过的数组元素的值标为-1，下次不再访问，避免冗余。

```javascript
var arrayNesting = function(nums) {
    var max=0;
    for(var i=0;i<nums.length;++i)
    {
        var count=0,k=i;
        while(nums[k]!=-1)
        {
            count++;
            var temp = nums[k];
            nums[k] = -1;
            k = temp;
        }
        max = Math.max(count,max);
    }
    return max;
};
```

## 5.最多能完成排序的块

[769. 最多能完成排序的块](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/)

**题目：** 数组arr是[0, 1, ..., arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。

我们最多能将数组分成多少块？

**示例：** 

```
输入: arr = [4,3,2,1,0]
输出: 1
解释:
将数组分成2块或者更多块，都无法得到所需的结果。
例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。
```

**方法：** 块内最大数应该等于块的右边界的下标。

```javascript
var maxChunksToSorted = function(arr) {
    var count = 0;
    var right = arr[0];
    for(let i=0;i<arr.length;++i)
    {
        right = Math.max(right,arr[i]);
        if(right==i)
        {
            count++;
        }
    }
    return count;
};
```

